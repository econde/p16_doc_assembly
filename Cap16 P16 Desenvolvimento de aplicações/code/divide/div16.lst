PDS16 assembler v0.0(Jan 29 2019)	div16.lst	Mon Feb  4 17:38:09 2019


Sections
Index   Name            Addresses       Size
0       .startup        0000 - 000b     000c 12
1       .stack          000c - 004b     0040 64
2       .data           004c - 0051     0006 6
3       .text           0052 - 0089     0038 56

Symbols
Name                    Type      Value      Section
div_while               LABEL     0072 114   .text
addr_z                  LABEL     0068 104   .text
div                     LABEL     006a 106   .text
addr_x                  LABEL     0064 100   .text
z                       LABEL     0050 80    .data
y                       LABEL     004e 78    .data
addr_y                  LABEL     0066 102   .text
STACK_SIZE              ABSOLUTE  0040 64    .startup
line#3                  LABEL     0002 2     .startup
x                       LABEL     004c 76    .data
addr_stack_top          LABEL     000a 10    .startup
_start                  LABEL     0004 4     .startup
stack_top               LABEL     004c 76    .stack
main                    LABEL     0052 82    .text
div_if_end              LABEL     0080 128   .text
line#8                  LABEL     0008 8     .startup

Code listing
   1              		.section .startup
   2 0000 0158    		b	_start
   3 0002 ff5b    		b	.
   4              	
   5              	_start:
   6 0004 2d0c    		ldr	sp, addr_stack_top
   7 0006 255c    		bl	main
   8 0008 ff5b    		b	.
   9              	
  10              	addr_stack_top:
  11 000a 4c00    		.word	stack_top
  12              	
  13              		.section .stack
  14              		.equ	STACK_SIZE, 64
  15 000c 00000000		.space	STACK_SIZE
  15 0010 00000000
  15 0014 00000000
  15 0018 00000000
  16              	stack_top:
  17              	
  18              	/*-----------------------------------------------------------------------------
  19              	int x = 30, y = 4, z;
  20              	
  21              	int main() {
  22              		z = div(x, y);
  23              	}
  24              	*/
  25              		.data
  26              	x:
  27 004c 1e00    		.word	30
  28              	y:
  29 004e 0400    		.word	4
  30              	z:
  31 0050 0000    		.word	0
  32              		
  33              		.text
  34              	main:
  35 0052 0e24    		push	lr
  36 0054 700c    		ldr	r0, addr_x
  37 0056 0000    		ldr	r0, [r0]
  38 0058 610c    		ldr	r1, addr_y
  39 005a 1100    		ldr	r1, [r1]
  40 005c 065c    		bl	div
  41 005e 410c    		ldr	r1, addr_z	
  42 0060 1020    		str	r0, [r1]
  43 0062 0f04    		pop	pc
  44              	
  45              	addr_x:
  46 0064 4c00    		.word	x
  47              	addr_y:
  48 0066 4e00    		.word	y
  49              	addr_z:
  50 0068 5000    		.word	z
  51              	
  52              	/*--------------------------------------------------------------------
  53              	<r0> uint16_t int div(<r0> uint16 dividend, <r1> uint16_t divisor) {
  54              		<r3> uint16_t rest = 0, <r4> quocient = 0;
  55              		<r2> uint16_t i = 16;
  56              		do {
  57              			uint16 dividend_msb = dividend >> 15;
  58              			dividend <<= 1;
  59              			rest = (rest << 1) | dividend_msb;
  60              			quotient <<= 1;
  61              			if (rest >= divisor) {
  62              				rest -= divisor;
  63              				quotient += 1;
  64              			}
  65              		} while (--i > 0);
  66              		return quotient (r0);
  67              	}
  68              	*/
  69              	
  70              	div:
  71 006a 0424    		push	r4
  72 006c 0360    		mov	r3, 0		; rest = 0;
  73 006e 0460    		mov	r4, 0		; quocient = 0;
  74 0070 0261    		mov	r2, 16		; uint16_t i = 16;
  75              	div_while:			; uint16 dividend_msb = dividend >> 15;
  76 0072 80e0    		lsl	r0, r0, 1	; dividend <<= 1;
  77 0074 b391    		adc	r3, r3, r3	; rest = (rest << 1) | dividend_msb;
  78 0076 c4e0    		lsl	r4, r4, 1	; quotient <<= 1;
  79 0078 b0b8    		cmp	r3, r1		; if (rest >= divisor) {
  80 007a 0248    		blo	div_if_end
  81 007c b388    		sub	r3, r3, r1	; rest -= divisor;
  82 007e c4a0    		add	r4, r4, 1	; quotient += 1;
  83              	div_if_end:
  84 0080 a2a8    		sub	r2, r2, 1	; } while (--i > 0);
  85 0082 f747    		bne	div_while
  86 0084 00b2    		mov	r0, r4		; return quotient;
  87 0086 0404    		pop	r4
  88 0088 0fb7    		mov	pc, lr
