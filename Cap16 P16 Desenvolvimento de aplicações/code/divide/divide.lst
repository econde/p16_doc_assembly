P16 assembler v1.2 (Apr  8 2019)	divide.lst	Mon Apr  8 11:03:48 2019

Sections
Index   Name            Addresses       Size
0       .startup        0000 - 000B     000C 12
1       .stack          000C - 004B     0040 64
2       .data           004C - 0051     0006 6
3       .text           0052 - 0089     0038 56

Symbols
Name                    Type      Value      Section
divide                  LABEL     006A 106   .text
addr_x                  LABEL     0064 100   .text
z                       LABEL     0050 80    .data
main                    LABEL     0052 82    .text
addr_stack_top          LABEL     000A 10    .startup
addr_z                  LABEL     0068 104   .text
line#3                  LABEL     0002 2     .startup
div_if_end              LABEL     0080 128   .text
div_while               LABEL     0072 114   .text
_start                  LABEL     0004 4     .startup
line#8                  LABEL     0008 8     .startup
addr_y                  LABEL     0066 102   .text
stack_top               LABEL     004C 76    .stack
x                       LABEL     004C 76    .data
y                       LABEL     004E 78    .data
STACK_SIZE              ABSOLUTE  0040 64    .stack

Code listing
   1              		.section .startup
   2 0000 0158    		b	_start
   3 0002 FF5B    		b	.
   4              	
   5              	_start:
   6 0004 2D0C    		ldr	sp, addr_stack_top
   7 0006 255C    		bl	main
   8 0008 FF5B    		b	.
   9              	
  10              	addr_stack_top:
  11 000A 4C00    		.word	stack_top
  12              	
  13              		.section .stack
  14              		.equ	STACK_SIZE, 64
  15 000C 00000000		.space	STACK_SIZE
  15 0010 00000000
  15 0014 00000000
  15 0018 00000000
  16              	stack_top:
  17              	
  18              	/*---------------------------------------------------------------
  19              	int x = 30, y = 4, z;
  20              	
  21              	int main() {
  22              		z = div(x, y);
  23              	}
  24              	*/
  25              		.data
  26              	x:
  27 004C 1E00    		.word	30
  28              	y:
  29 004E 0400    		.word	4
  30              	z:
  31 0050 0000    		.word	0
  32              		
  33              		.text
  34              	main:
  35 0052 0E24    		push	lr
  36 0054 700C    		ldr	r0, addr_x
  37 0056 0000    		ldr	r0, [r0]
  38 0058 610C    		ldr	r1, addr_y
  39 005A 1100    		ldr	r1, [r1]
  40 005C 065C    		bl	divide
  41 005E 410C    		ldr	r1, addr_z	
  42 0060 1020    		str	r0, [r1]
  43 0062 0F04    		pop	pc
  44              	
  45              	addr_x:
  46 0064 4C00    		.word	x
  47              	addr_y:
  48 0066 4E00    		.word	y
  49              	addr_z:
  50 0068 5000    		.word	z
  51              	
  52              	/*--------------------------------------------------------------------
  53              	<r0> uint16_t int divide(<r0> uint16 dividend, <r1> uint16_t divisor){
  54              		<r2> uint16_t i = 16;
  55              		<r3> uint16_t remainder = 0, <r4> quotient = 0;
  56              		do {
  57              			uint16 dividend_msb = dividend >> 15;
  58              			dividend <<= 1;
  59              			rest = ( remainder << 1) | dividend_msb;
  60              			quotient <<= 1;
  61              			if (remainder >= divisor) {
  62              				remainder -= divisor;
  63              				quotient += 1;
  64              			}
  65              		} while (--i > 0);
  66              		return quotient (r0);
  67              	}
  68              	*/
  69              	
  70              	divide:
  71 006A 0424    		push	r4
  72 006C 0360    		mov	r3, 0		; remainder = 0;
  73 006E 0460    		mov	r4, 0		; quotient = 0;
  74 0070 0261    		mov	r2, 16	; uint16_t i = 16;
  75              	div_while:			; uint16 dividend_msb = dividend >> 15;
  76 0072 80E0    		lsl	r0, r0, 1	; dividend <<= 1;
  77 0074 B391    		adc	r3, r3, r3	; rest = (rest << 1) | dividend_msb;
  78 0076 C4E0    		lsl	r4, r4, 1	; quotient <<= 1;
  79 0078 B0B8    		cmp	r3, r1	; if ( remainder >= divisor) {
  80 007A 0248    		blo	div_if_end
  81 007C B388    		sub	r3, r3, r1	; remainder -= divisor;
  82 007E C4A0    		add	r4, r4, 1	; quotient += 1;
  83              	div_if_end:
  84 0080 A2A8    		sub	r2, r2, 1	; } while (--i > 0);
  85 0082 F747    		bne	div_while
  86 0084 00B2    		mov	r0, r4	; return quotient;
  87 0086 0404    		pop	r4
  88 0088 0FB7    		mov	pc, lr
